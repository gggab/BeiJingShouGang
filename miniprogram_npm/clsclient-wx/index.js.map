{"version":3,"sources":["CLSClient.umd.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n(function(global2, factory) {\n  typeof exports === \"object\" && typeof module !== \"undefined\" ? factory(exports, require(\"abab\"), require(\"jssha\")) : typeof define === \"function\" && define.amd ? define([\"exports\", \"abab\", \"jssha\"], factory) : (global2 = typeof globalThis !== \"undefined\" ? globalThis : global2 || self, factory(global2.CLSClient = {}, global2.abab, global2.jssha));\n})(this, function(exports2, abab, jsSHA) {\n  \n  const _interopDefaultLegacy = (e) => e && typeof e === \"object\" && \"default\" in e ? e : { default: e };\n  const jsSHA__default = /* @__PURE__ */ _interopDefaultLegacy(jsSHA);\n  class Vec3 {\n    constructor(x, y, z) {\n      this.x = x ? x : 0;\n      this.y = y ? y : 0;\n      this.z = z ? z : 0;\n    }\n    set(x, y, z) {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n    }\n    clone() {\n      let v = new Vec3(this.x, this.y, this.z);\n      return v;\n    }\n    scale(n) {\n      this.x *= n;\n      this.y *= n;\n      this.z *= n;\n      return this;\n    }\n    getLength() {\n      let lengthSq = this.x * this.x + this.y * this.y + this.z * this.z;\n      return Math.sqrt(lengthSq);\n    }\n    getLengthSq() {\n      let lengthSq = this.x * this.x + this.y * this.y + this.z * this.z;\n      return lengthSq;\n    }\n    normalize() {\n      let lengthSq = this.x * this.x + this.y * this.y + this.z * this.z;\n      if (lengthSq > 0) {\n        var invLength = 1 / Math.sqrt(lengthSq);\n        this.x *= invLength;\n        this.y *= invLength;\n        this.z *= invLength;\n      }\n      return this;\n    }\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n      return this;\n    }\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n      return this;\n    }\n    distance(v) {\n      let diff = this.clone().sub(v);\n      let d = diff.getLength();\n      return d;\n    }\n    dot(v) {\n      let val = this.x * v.x + this.y * v.y + this.z * v.z;\n      return val;\n    }\n    getAngle(v) {\n      let dotVal = this.dot(v);\n      let t = dotVal / (this.getLength() * v.getLength());\n      let angle = Math.acos(t) * 180 / Math.PI;\n      return angle;\n    }\n  }\n  class Quat {\n    constructor() {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n      this.w = 0;\n    }\n    setFromMat4(m) {\n      let quat = this;\n      let m00, m01, m02, m10, m11, m12, m20, m21, m22, tr, s, rs, lx, ly, lz;\n      m00 = m.data[0];\n      m01 = m.data[4];\n      m02 = m.data[8];\n      m10 = m.data[1];\n      m11 = m.data[5];\n      m12 = m.data[9];\n      m20 = m.data[2];\n      m21 = m.data[6];\n      m22 = m.data[10];\n      lx = m00 * m00 + m01 * m01 + m02 * m02;\n      if (lx === 0)\n        return quat;\n      lx = 1 / Math.sqrt(lx);\n      ly = m10 * m10 + m11 * m11 + m12 * m12;\n      if (ly === 0)\n        return quat;\n      ly = 1 / Math.sqrt(ly);\n      lz = m20 * m20 + m21 * m21 + m22 * m22;\n      if (lz === 0)\n        return quat;\n      lz = 1 / Math.sqrt(lz);\n      m00 *= lx;\n      m01 *= lx;\n      m02 *= lx;\n      m10 *= ly;\n      m11 *= ly;\n      m12 *= ly;\n      m20 *= lz;\n      m21 *= lz;\n      m22 *= lz;\n      tr = m00 + m11 + m22;\n      if (tr >= 0) {\n        s = Math.sqrt(tr + 1);\n        quat.w = s * 0.5;\n        s = 0.5 / s;\n        quat.x = (m12 - m21) * s;\n        quat.y = (m20 - m02) * s;\n        quat.z = (m01 - m10) * s;\n      } else {\n        if (m00 > m11) {\n          if (m00 > m22) {\n            rs = m00 - (m11 + m22) + 1;\n            rs = Math.sqrt(rs);\n            quat.x = rs * 0.5;\n            rs = 0.5 / rs;\n            quat.w = (m12 - m21) * rs;\n            quat.y = (m01 + m10) * rs;\n            quat.z = (m02 + m20) * rs;\n          } else {\n            rs = m22 - (m00 + m11) + 1;\n            rs = Math.sqrt(rs);\n            quat.z = rs * 0.5;\n            rs = 0.5 / rs;\n            quat.w = (m01 - m10) * rs;\n            quat.x = (m20 + m02) * rs;\n            quat.y = (m21 + m12) * rs;\n          }\n        } else if (m11 > m22) {\n          rs = m11 - (m22 + m00) + 1;\n          rs = Math.sqrt(rs);\n          quat.y = rs * 0.5;\n          rs = 0.5 / rs;\n          quat.w = (m20 - m02) * rs;\n          quat.z = (m12 + m21) * rs;\n          quat.x = (m10 + m01) * rs;\n        } else {\n          rs = m22 - (m00 + m11) + 1;\n          rs = Math.sqrt(rs);\n          quat.z = rs * 0.5;\n          rs = 0.5 / rs;\n          quat.w = (m01 - m10) * rs;\n          quat.x = (m20 + m02) * rs;\n          quat.y = (m21 + m12) * rs;\n        }\n      }\n      return quat;\n    }\n    slerp(lhs, rhs, alpha) {\n      const lx = lhs.x;\n      const ly = lhs.y;\n      const lz = lhs.z;\n      const lw = lhs.w;\n      let rx = rhs.x;\n      let ry = rhs.y;\n      let rz = rhs.z;\n      let rw = rhs.w;\n      let cosHalfTheta = lw * rw + lx * rx + ly * ry + lz * rz;\n      if (cosHalfTheta < 0) {\n        rw = -rw;\n        rx = -rx;\n        ry = -ry;\n        rz = -rz;\n        cosHalfTheta = -cosHalfTheta;\n      }\n      if (Math.abs(cosHalfTheta) >= 1) {\n        this.w = lw;\n        this.x = lx;\n        this.y = ly;\n        this.z = lz;\n        return this;\n      }\n      const halfTheta = Math.acos(cosHalfTheta);\n      const sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);\n      if (Math.abs(sinHalfTheta) < 1e-3) {\n        this.w = lw * 0.5 + rw * 0.5;\n        this.x = lx * 0.5 + rx * 0.5;\n        this.y = ly * 0.5 + ry * 0.5;\n        this.z = lz * 0.5 + rz * 0.5;\n        return this;\n      }\n      const ratioA = Math.sin((1 - alpha) * halfTheta) / sinHalfTheta;\n      const ratioB = Math.sin(alpha * halfTheta) / sinHalfTheta;\n      this.w = lw * ratioA + rw * ratioB;\n      this.x = lx * ratioA + rx * ratioB;\n      this.y = ly * ratioA + ry * ratioB;\n      this.z = lz * ratioA + rz * ratioB;\n      return this;\n    }\n  }\n  class Mat4 {\n    constructor() {\n      __publicField(this, \"data\");\n      let data = new Float32Array(16);\n      data[0] = data[5] = data[10] = data[15] = 1;\n      this.data = data;\n    }\n    static fromArray(data) {\n      return new Mat4().set(data);\n    }\n    set(m) {\n      for (let i = 0; i < m.length; i++) {\n        this.data[i] = m[i];\n      }\n      return this;\n    }\n    clone() {\n      let m = new Mat4();\n      m.set(this.data);\n      return m;\n    }\n    transpose() {\n      let te = this.data;\n      let tmp;\n      tmp = te[1];\n      te[1] = te[4];\n      te[4] = tmp;\n      tmp = te[2];\n      te[2] = te[8];\n      te[8] = tmp;\n      tmp = te[6];\n      te[6] = te[9];\n      te[9] = tmp;\n      tmp = te[3];\n      te[3] = te[12];\n      te[12] = tmp;\n      tmp = te[7];\n      te[7] = te[13];\n      te[13] = tmp;\n      tmp = te[11];\n      te[11] = te[14];\n      te[14] = tmp;\n      return this;\n    }\n    getInverse() {\n      let me = this.data;\n      let te = [], n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n      let det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n      if (det === 0) {\n        throw new Error(\"error!\");\n      }\n      let detInv = 1 / det;\n      te[0] = t11 * detInv;\n      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n      te[4] = t12 * detInv;\n      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n      te[8] = t13 * detInv;\n      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n      te[12] = t14 * detInv;\n      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n      this.data = new Float32Array(te);\n      return this;\n    }\n    determinant() {\n      const te = this.data;\n      const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\n      const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\n      const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\n      const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\n      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n    }\n    decompose() {\n      const te = this.data;\n      let sx = new Vec3(te[0], te[1], te[2]).getLength();\n      let sy = new Vec3(te[4], te[5], te[6]).getLength();\n      let sz = new Vec3(te[8], te[9], te[10]).getLength();\n      const det = this.determinant();\n      if (det < 0)\n        sx = -sx;\n      let position = new Vec3(te[12], te[13], te[14]);\n      let rotation = new Mat4();\n      rotation.set(this.data);\n      const invSX = 1 / sx;\n      const invSY = 1 / sy;\n      const invSZ = 1 / sz;\n      rotation.data[0] *= invSX;\n      rotation.data[1] *= invSX;\n      rotation.data[2] *= invSX;\n      rotation.data[4] *= invSY;\n      rotation.data[5] *= invSY;\n      rotation.data[6] *= invSY;\n      rotation.data[8] *= invSZ;\n      rotation.data[9] *= invSZ;\n      rotation.data[10] *= invSZ;\n      let scale = new Vec3(sx, sy, sz);\n      scale.x = sx;\n      scale.y = sy;\n      scale.z = sz;\n      return { position, rotation, scale };\n    }\n    mul2(lhs, rhs) {\n      const a = lhs.data;\n      const b = rhs.data;\n      const r = this.data;\n      const a00 = a[0];\n      const a01 = a[1];\n      const a02 = a[2];\n      const a03 = a[3];\n      const a10 = a[4];\n      const a11 = a[5];\n      const a12 = a[6];\n      const a13 = a[7];\n      const a20 = a[8];\n      const a21 = a[9];\n      const a22 = a[10];\n      const a23 = a[11];\n      const a30 = a[12];\n      const a31 = a[13];\n      const a32 = a[14];\n      const a33 = a[15];\n      let b0, b1, b2, b3;\n      b0 = b[0];\n      b1 = b[1];\n      b2 = b[2];\n      b3 = b[3];\n      r[0] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n      r[1] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n      r[2] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n      r[3] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n      b0 = b[4];\n      b1 = b[5];\n      b2 = b[6];\n      b3 = b[7];\n      r[4] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n      r[5] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n      r[6] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n      r[7] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n      b0 = b[8];\n      b1 = b[9];\n      b2 = b[10];\n      b3 = b[11];\n      r[8] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n      r[9] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n      r[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n      r[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n      b0 = b[12];\n      b1 = b[13];\n      b2 = b[14];\n      b3 = b[15];\n      r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n      r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n      r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n      r[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n      return this;\n    }\n    compose(position, quaternion, scale) {\n      const te = this.data;\n      const x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;\n      const x2 = x + x, y2 = y + y, z2 = z + z;\n      const xx = x * x2, xy = x * y2, xz = x * z2;\n      const yy = y * y2, yz = y * z2, zz = z * z2;\n      const wx2 = w * x2, wy = w * y2, wz = w * z2;\n      const sx = scale.x, sy = scale.y, sz = scale.z;\n      te[0] = (1 - (yy + zz)) * sx;\n      te[1] = (xy + wz) * sx;\n      te[2] = (xz - wy) * sx;\n      te[3] = 0;\n      te[4] = (xy - wz) * sy;\n      te[5] = (1 - (xx + zz)) * sy;\n      te[6] = (yz + wx2) * sy;\n      te[7] = 0;\n      te[8] = (xz + wy) * sz;\n      te[9] = (yz - wx2) * sz;\n      te[10] = (1 - (xx + yy)) * sz;\n      te[11] = 0;\n      te[12] = position.x;\n      te[13] = position.y;\n      te[14] = position.z;\n      te[15] = 1;\n      return this;\n    }\n    setTRS(t, r, s) {\n      var tx, ty, tz, qx, qy, qz, qw, sx, sy, sz, x2, y2, z2, xx, xy, xz, yy, yz, zz, wx2, wy, wz, m;\n      tx = t.x;\n      ty = t.y;\n      tz = t.z;\n      qx = r.x;\n      qy = r.y;\n      qz = r.z;\n      qw = r.w;\n      sx = s.x;\n      sy = s.y;\n      sz = s.z;\n      x2 = qx + qx;\n      y2 = qy + qy;\n      z2 = qz + qz;\n      xx = qx * x2;\n      xy = qx * y2;\n      xz = qx * z2;\n      yy = qy * y2;\n      yz = qy * z2;\n      zz = qz * z2;\n      wx2 = qw * x2;\n      wy = qw * y2;\n      wz = qw * z2;\n      m = this.data;\n      m[0] = (1 - (yy + zz)) * sx;\n      m[1] = (xy + wz) * sx;\n      m[2] = (xz - wy) * sx;\n      m[3] = 0;\n      m[4] = (xy - wz) * sy;\n      m[5] = (1 - (xx + zz)) * sy;\n      m[6] = (yz + wx2) * sy;\n      m[7] = 0;\n      m[8] = (xz + wy) * sz;\n      m[9] = (yz - wx2) * sz;\n      m[10] = (1 - (xx + yy)) * sz;\n      m[11] = 0;\n      m[12] = tx;\n      m[13] = ty;\n      m[14] = tz;\n      m[15] = 1;\n      return this;\n    }\n    multiplyMatrices(a, b) {\n      const ae = a.data;\n      const be = b.data;\n      const te = this.data;\n      const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\n      const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\n      const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\n      const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\n      const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\n      const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\n      const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\n      const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\n      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n      return this;\n    }\n    makePerspective(left, right, top, bottom, near, far) {\n      if (far === void 0) {\n        console.warn(\"THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.\");\n      }\n      const te = this.data;\n      const x = 2 * near / (right - left);\n      const y = 2 * near / (top - bottom);\n      const a = (right + left) / (right - left);\n      const b = (top + bottom) / (top - bottom);\n      const c = -(far + near) / (far - near);\n      const d = -2 * far * near / (far - near);\n      te[0] = x;\n      te[4] = 0;\n      te[8] = a;\n      te[12] = 0;\n      te[1] = 0;\n      te[5] = y;\n      te[9] = b;\n      te[13] = 0;\n      te[2] = 0;\n      te[6] = 0;\n      te[10] = c;\n      te[14] = d;\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = -1;\n      te[15] = 0;\n      return this;\n    }\n    makeOrthographic(left, right, top, bottom, near, far) {\n      const te = this.data;\n      const w = 1 / (right - left);\n      const h = 1 / (top - bottom);\n      const p = 1 / (far - near);\n      const x = (right + left) * w;\n      const y = (top + bottom) * h;\n      const z = (far + near) * p;\n      te[0] = 2 * w;\n      te[4] = 0;\n      te[8] = 0;\n      te[12] = -x;\n      te[1] = 0;\n      te[5] = 2 * h;\n      te[9] = 0;\n      te[13] = -y;\n      te[2] = 0;\n      te[6] = 0;\n      te[10] = -2 * p;\n      te[14] = -z;\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = 0;\n      te[15] = 1;\n      return this;\n    }\n    toJSON() {\n      return Array.from(this.data);\n    }\n  }\n  function compareVersion(v1, v2) {\n    v1 = v1.split(\".\");\n    v2 = v2.split(\".\");\n    const len = Math.max(v1.length, v2.length);\n    while (v1.length < len) {\n      v1.push(\"0\");\n    }\n    while (v2.length < len) {\n      v2.push(\"0\");\n    }\n    for (let i = 0; i < len; i++) {\n      const num1 = parseInt(v1[i]);\n      const num2 = parseInt(v2[i]);\n      if (num1 > num2) {\n        return 1;\n      } else if (num1 < num2) {\n        return -1;\n      }\n    }\n    return 0;\n  }\n  function isLastV43(v) {\n    return compareVersion(v, \"4.3\") >= 0;\n  }\n  function assert(v, msg) {\n    if (!v)\n      throw new Error(msg);\n  }\n  function processPoseSchema(pose) {\n    let mat = new Mat4();\n    mat.set(pose);\n    let cameraMat = mat.clone().transpose();\n    let { position, rotation, scale } = cameraMat.decompose();\n    let nor = new Vec3(cameraMat.data[8], cameraMat.data[9], cameraMat.data[10]);\n    let forward = nor.normalize().scale(-1);\n    return { position, forward, rotation, scale };\n  }\n  function processPoseCamera(pose) {\n    let mat = new Mat4();\n    mat.set(pose);\n    let cameraMat = mat.clone().transpose().getInverse();\n    let { position, rotation, scale } = cameraMat.decompose();\n    let nor = new Vec3(cameraMat.data[8], cameraMat.data[9], cameraMat.data[10]);\n    let forward = nor.normalize().scale(-1);\n    return { position, forward, rotation, scale };\n  }\n  const globalUrl = \"https://global.easyar.cn\";\n  const arocUrl = \"https://aroc-api.easyar.com\";\n  const clsUrl = \"https://cls-api.easyar.com\";\n  const clsV3Url = \"https://clsv3-api.easyar.com\";\n  const uacUrl = \"https://uac.easyar.com\";\n  const config = {\n    globalUrl,\n    arocUrl,\n    clsUrl,\n    uacUrl,\n    clsV3Url,\n    emaUrl: \"https://large-spatialmaps.easyar.com\"\n  };\n  function getClsHost(clsVersion, originalHost) {\n    if (originalHost && [config.clsV3Url, config.clsUrl].indexOf(originalHost) < 0)\n      return originalHost;\n    return isLastV43(clsVersion) ? config.clsV3Url : config.clsUrl;\n  }\n  function getClsUrl(clsVersion) {\n    let version = \"\";\n    if (clsVersion.indexOf(\".\") >= 0)\n      version = clsVersion.split(\".\")[0];\n    if (clsVersion === \"2\")\n      clsVersion = \"3\";\n    let gpu = clsVersion === \"3\";\n    let gpuPath = gpu ? \"/gpu\" : \"\";\n    return `${getClsHost(clsVersion, config.clsUrl)}/v${version}${gpuPath}/file/localize`;\n  }\n  const request = request_mini;\n  async function request_mini(url, method, params, headers, data) {\n    let keys = Object.keys(params || {});\n    let paramString = keys.length ? keys.map((key) => `${key}=${encodeURIComponent(params[key])}`).join(\"&\") : void 0;\n    let urlFinal = url + (paramString ? `?${paramString}` : \"\");\n    return new Promise((resolve, reject) => {\n      let option = {\n        url: urlFinal,\n        method,\n        success: (res) => {\n          resolve(res.data);\n        },\n        fail: (e) => {\n          reject(e);\n        }\n      };\n      if (headers)\n        option.header = headers;\n      if (data)\n        option.data = data;\n      wx.request(option);\n    });\n  }\n  function getClsInfoAnonymous(id) {\n    return request(`${config.globalUrl}/anonymous/cls/${id}`, \"GET\", {}, null, null);\n  }\n  function getArannotations(host, appId, authorization) {\n    return request(`${host}/cls/arannotations`, \"GET\", { appId, pageNum: 1, pageSize: 100 }, { authorization }, null);\n  }\n  function getArannotation(host, araId, appId, authorization) {\n    return request(`${host}/cls/arannotation/${araId}`, \"GET\", { appId }, { authorization }, null);\n  }\n  function getPoseFusion(pose, resolve) {\n    let params = JSON.stringify(pose);\n    return request(\"https://posefusion.easyar.com/pose/v1\", \"POST\", null, null, params).then((res) => {\n      return resolve(res);\n    });\n  }\n  function sha256(msg) {\n    let shaObj = new jsSHA__default.default(\"SHA-256\", \"TEXT\");\n    shaObj.update(msg);\n    return shaObj.getHash(\"HEX\");\n  }\n  let tokens = {};\n  let tokenExpireTimes = {};\n  function getToken(apiKey, apiSecret) {\n    let timestamp = new Date().getTime();\n    if (tokenExpireTimes[apiKey] && timestamp < tokenExpireTimes[apiKey] && tokens[apiKey]) {\n      return Promise.resolve(tokens[apiKey]);\n    }\n    const expires = 3600;\n    tokenExpireTimes[apiKey] = timestamp + expires * 1e3;\n    let params = { expires, timestamp, apiKey };\n    let signStr = Object.keys(params).sort().map((key) => `${key}${params[key]}`).concat(apiSecret).join(\"\");\n    params.signature = sha256(signStr);\n    return request(`${config.uacUrl}/token/v2`, \"POST\", null, null, params).then((res) => {\n      if (res.result && res.result.token) {\n        tokens[apiKey] = res.result.token;\n        return tokens[apiKey];\n      }\n      console.log(\"token error\");\n      return \"TOKEN_ERROR\";\n    });\n  }\n  function cubeListsFromEma(ema, meta) {\n    var _a, _b, _c;\n    let clusters = {};\n    let blocks = {};\n    let maps = {};\n    let relationships = [];\n    if (ema.clusters)\n      for (let cluster of ema.clusters) {\n        clusters[cluster.id] = [];\n      }\n    if (ema.blocks)\n      for (let block of ema.blocks) {\n        blocks[block.id] = [];\n      }\n    if (ema.extensions) {\n      let aliasExtension = ema.extensions.find(\n        (e) => e.vender === \"EasyAR\" && e.name === \"BlockAlias\"\n      );\n      if (aliasExtension) {\n        if (aliasExtension.details.blocks) {\n          for (let blockAlias of aliasExtension.details.blocks) {\n            let src = blockAlias.id;\n            for (let dest of blockAlias.aliases) {\n              blocks[dest] = blocks[src];\n            }\n          }\n        }\n      }\n    }\n    if (ema.annotations)\n      for (let annotation of ema.annotations) {\n        if (annotation.parent) {\n          let parentArray = null;\n          switch (annotation.parent.type) {\n            case \"cluster\":\n              parentArray = clusters[annotation.parent.id];\n              break;\n            case \"block\":\n              parentArray = blocks[annotation.parent.id];\n              break;\n            case \"map\":\n              parentArray = maps[annotation.parent.id] || [];\n              maps[annotation.parent.id] = parentArray;\n              break;\n          }\n          if (parentArray) {\n            parentArray.push({\n              name: ((_a = annotation.properties) == null ? void 0 : _a.name) || annotation.name,\n              position: annotation.transform.position,\n              quat: annotation.transform.rotation,\n              scale: annotation.transform.scale,\n              origin: annotation\n            });\n          } else {\n            console.warn(`annotation ${((_b = annotation.properties) == null ? void 0 : _b.name) || annotation.name} \\u672A\\u627E\\u5230parent`, annotation);\n          }\n        } else if (annotation.type) {\n          switch (annotation.type) {\n            case \"relationship\":\n              relationships.push(annotation);\n              break;\n            case \"block\":\n              break;\n            case \"map\":\n              break;\n            default:\n              console.log(`unexpected type`, annotation.type);\n              break;\n          }\n        } else {\n          console.warn(`annotation ${((_c = annotation.properties) == null ? void 0 : _c.name) || annotation.name} \\u6CA1\\u6709parent`, annotation);\n        }\n      }\n    return { clusters, blocks, maps, relationships };\n  }\n  const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  const lookup = new Uint8Array(256);\n  for (let i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n  }\n  function base64ToArrayBuffer(base64) {\n    let bufferLength = base64.length * 0.75;\n    const len = base64.length;\n    let i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === \"=\") {\n      bufferLength--;\n      if (base64[base64.length - 2] === \"=\") {\n        bufferLength--;\n      }\n    }\n    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n      encoded1 = lookup[base64.charCodeAt(i)];\n      encoded2 = lookup[base64.charCodeAt(i + 1)];\n      encoded3 = lookup[base64.charCodeAt(i + 2)];\n      encoded4 = lookup[base64.charCodeAt(i + 3)];\n      bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n      bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n      bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return arraybuffer;\n  }\n  const text = function(l) {\n    function m() {\n    }\n    function k(a, c) {\n      a = void 0 === a ? \"utf-8\" : a;\n      c = void 0 === c ? { fatal: false } : c;\n      if (-1 === r.indexOf(a.toLowerCase()))\n        throw new RangeError(\"Failed to construct 'TextDecoder': The encoding label provided ('\" + a + \"') is invalid.\");\n      if (c.fatal)\n        throw Error(\"Failed to construct 'TextDecoder': the 'fatal' option is unsupported.\");\n    }\n    function t(a) {\n      return Buffer.from(a.buffer, a.byteOffset, a.byteLength).toString(\"utf-8\");\n    }\n    function u(a) {\n      var c = URL.createObjectURL(new Blob([a], { type: \"text/plain;charset=UTF-8\" }));\n      try {\n        var f = new XMLHttpRequest();\n        f.open(\"GET\", c, false);\n        f.send();\n        return f.responseText;\n      } catch (e) {\n        return q(a);\n      } finally {\n        URL.revokeObjectURL(c);\n      }\n    }\n    function q(a) {\n      for (var c = 0, f = Math.min(65536, a.length + 1), e = new Uint16Array(f), h = [], d = 0; ; ) {\n        var b = c < a.length;\n        if (!b || d >= f - 1) {\n          h.push(String.fromCharCode.apply(null, e.subarray(0, d)));\n          if (!b)\n            return h.join(\"\");\n          a = a.subarray(c);\n          d = c = 0;\n        }\n        b = a[c++];\n        if (0 === (b & 128))\n          e[d++] = b;\n        else if (192 === (b & 224)) {\n          var g = a[c++] & 63;\n          e[d++] = (b & 31) << 6 | g;\n        } else if (224 === (b & 240)) {\n          g = a[c++] & 63;\n          var n = a[c++] & 63;\n          e[d++] = (b & 31) << 12 | g << 6 | n;\n        } else if (240 === (b & 248)) {\n          g = a[c++] & 63;\n          n = a[c++] & 63;\n          var v = a[c++] & 63;\n          b = (b & 7) << 18 | g << 12 | n << 6 | v;\n          65535 < b && (b -= 65536, e[d++] = b >>> 10 & 1023 | 55296, b = 56320 | b & 1023);\n          e[d++] = b;\n        }\n      }\n    }\n    if (l.TextEncoder && l.TextDecoder)\n      return l;\n    var r = [\"utf-8\", \"utf8\", \"unicode-1-1-utf-8\"];\n    Object.defineProperty(m.prototype, \"encoding\", { value: \"utf-8\" });\n    m.prototype.encode = function(a, c) {\n      c = void 0 === c ? { stream: false } : c;\n      if (c.stream)\n        throw Error(\"Failed to encode: the 'stream' option is unsupported.\");\n      c = 0;\n      for (var f = a.length, e = 0, h = Math.max(\n        32,\n        f + (f >>> 1) + 7\n      ), d = new Uint8Array(h >>> 3 << 3); c < f; ) {\n        var b = a.charCodeAt(c++);\n        if (55296 <= b && 56319 >= b) {\n          if (c < f) {\n            var g = a.charCodeAt(c);\n            56320 === (g & 64512) && (++c, b = ((b & 1023) << 10) + (g & 1023) + 65536);\n          }\n          if (55296 <= b && 56319 >= b)\n            continue;\n        }\n        e + 4 > d.length && (h += 8, h *= 1 + c / a.length * 2, h = h >>> 3 << 3, g = new Uint8Array(h), g.set(d), d = g);\n        if (0 === (b & 4294967168))\n          d[e++] = b;\n        else {\n          if (0 === (b & 4294965248))\n            d[e++] = b >>> 6 & 31 | 192;\n          else if (0 === (b & 4294901760))\n            d[e++] = b >>> 12 & 15 | 224, d[e++] = b >>> 6 & 63 | 128;\n          else if (0 === (b & 4292870144))\n            d[e++] = b >>> 18 & 7 | 240, d[e++] = b >>> 12 & 63 | 128, d[e++] = b >>> 6 & 63 | 128;\n          else\n            continue;\n          d[e++] = b & 63 | 128;\n        }\n      }\n      return d.slice ? d.slice(0, e) : d.subarray(0, e);\n    };\n    Object.defineProperty(k.prototype, \"encoding\", { value: \"utf-8\" });\n    Object.defineProperty(k.prototype, \"fatal\", { value: false });\n    Object.defineProperty(k.prototype, \"ignoreBOM\", { value: false });\n    var p = q;\n    \"function\" === typeof Buffer && Buffer.from ? p = t : \"function\" === typeof Blob && \"function\" === typeof URL && \"function\" === typeof URL.createObjectURL && (p = u);\n    k.prototype.decode = function(a, c) {\n      c = void 0 === c ? { stream: false } : c;\n      if (c.stream)\n        throw Error(\"Failed to decode: the 'stream' option is unsupported.\");\n      a = a instanceof Uint8Array ? a : a.buffer instanceof ArrayBuffer ? new Uint8Array(a.buffer) : new Uint8Array(a);\n      return p(a);\n    };\n    l.TextEncoder = m;\n    l.TextDecoder = k;\n    return l;\n  }(\"undefined\" !== typeof window ? window : \"undefined\" !== typeof global ? global : globalThis);\n  const _PoseFusion = class {\n    constructor() {\n      __publicField(this, \"currentFusion\");\n      __publicField(this, \"poseFusionResult\");\n      __publicField(this, \"_enable\", true);\n      __publicField(this, \"poseFusions\");\n      __publicField(this, \"localFusion\");\n      __publicField(this, \"lastFusion\");\n      __publicField(this, \"isSlerp\");\n      __publicField(this, \"sFusion\");\n      __publicField(this, \"slerpTimestamp\");\n      __publicField(this, \"_isTimeFeature\", false);\n      this._enable = true;\n      this.poseFusions = [];\n      this.localFusion = null;\n      this.currentFusion = null;\n      this.lastFusion = null;\n      this.poseFusionResult = null;\n    }\n    static getInstance() {\n      if (!this._instance) {\n        this._instance = new _PoseFusion();\n      }\n      return this._instance;\n    }\n    get isTimeFeature() {\n      return this._isTimeFeature;\n    }\n    set isTimeFeature(value) {\n      if (this._isTimeFeature == value)\n        return;\n      this.currentFusion = null;\n      this.poseFusionResult = null;\n      this._isTimeFeature = value;\n      this._enable = !value;\n    }\n    get enable() {\n      return this._enable;\n    }\n    set enable(value) {\n      if (this._enable == value)\n        return;\n      if (value) {\n        this.currentFusion = null;\n        this.poseFusionResult = null;\n        this._updateCurrentFusion();\n      } else {\n        this._updateLocalFusion();\n      }\n      this._enable = value;\n    }\n    insertData(arKitPos, clsPose, timestamp) {\n      let param = {\n        localTwc: { data: arKitPos },\n        mapTcw: { data: clsPose },\n        timestamp: timestamp / 1e3\n      };\n      this.poseFusions.push(param);\n      let sliceIdx = 0;\n      while (param.timestamp - this.poseFusions[sliceIdx].timestamp > 90)\n        sliceIdx++;\n      if (sliceIdx > 0)\n        this.poseFusions = this.poseFusions.slice(sliceIdx);\n      if (this._isTimeFeature) {\n        this._updateTimeFeatureFusion();\n        return Promise.resolve({\n          status: 1,\n          fusionPose: Array.from(this.localFusion.clone().transpose().getInverse().data)\n        });\n      }\n      return new Promise((resolve) => {\n        if (this._enable) {\n          this._updateCurrentFusion().then(() => {\n            var _a, _b;\n            resolve({\n              status: (_a = this.poseFusionResult) == null ? void 0 : _a.status,\n              fusionPose: (_b = this.poseFusionResult) == null ? void 0 : _b.transform.data\n            });\n          });\n        } else {\n          this._updateLocalFusion();\n          resolve({\n            status: 0,\n            fusionPose: Array.from(this.localFusion.clone().transpose().getInverse().data)\n          });\n        }\n      });\n    }\n    _updateLocalFusion() {\n      if (this.poseFusions.length < 1)\n        return;\n      const lastFusionItem = this.poseFusions[this.poseFusions.length - 1];\n      const { localTwc, mapTcw } = lastFusionItem;\n      this.localFusion = new Mat4().mul2(\n        new Mat4().set(localTwc.data).transpose(),\n        new Mat4().set(mapTcw.data).transpose()\n      );\n    }\n    _updateCurrentFusion() {\n      if (this.poseFusions.length < 1)\n        return;\n      return getPoseFusion(this.poseFusions, (res) => {\n        const _lastResult = this.poseFusionResult ? this.poseFusionResult : res.result;\n        this.poseFusionResult = res.result;\n        if (this.poseFusionResult.status < _lastResult.status || this.poseFusionResult.timestamp < _lastResult.timestamp)\n          return;\n        const _pose = new Mat4().set(this.poseFusionResult.transform.data).transpose();\n        const inv_pose = _pose.clone().getInverse();\n        const temp_lastFusion = this.currentFusion ? this.currentFusion : inv_pose;\n        const temp_currentFusion = inv_pose;\n        this.isSlerp = !_PoseFusion.sim3DifferenceIsTooBig(\n          temp_lastFusion,\n          temp_currentFusion\n        );\n        if (this.isSlerp) {\n          this.sFusion = this.sFusion ? this.sFusion : temp_lastFusion;\n          this.lastFusion = this.sFusion;\n          this.slerpTimestamp = new Date().getTime();\n        }\n        this.currentFusion = temp_currentFusion;\n      });\n    }\n    _updateTimeFeatureFusion() {\n      if (this.poseFusions.length < 1)\n        return Promise.reject(\"poseFusion empty\");\n      return new Promise((rl, rj) => {\n        const { localTwc, mapTcw } = this.poseFusions[this.poseFusions.length - 1];\n        this.localFusion = new Mat4().mul2(new Mat4().set(localTwc.data).transpose(), new Mat4().set(mapTcw.data).transpose());\n        this.sFusion = this.sFusion || this.localFusion;\n        this.lastFusion = this.sFusion;\n        rl(null);\n      });\n    }\n    getPoseInMap(vm) {\n      if (this._isTimeFeature) {\n        return this.getTimeFeaturePose(vm);\n      }\n      const fusion = this._enable && this.currentFusion ? this.currentFusion : this.localFusion;\n      if (!fusion)\n        return null;\n      if (this._enable && this.isSlerp) {\n        const _time = (new Date().getTime() - this.slerpTimestamp) / 1e3;\n        const ratio = Math.min(1, _time);\n        this.sFusion = _PoseFusion.averageResult(this.lastFusion, fusion, ratio);\n      } else {\n        this.sFusion = fusion;\n      }\n      let _pose = new Mat4().mul2(vm.clone(), this.sFusion.clone()).getInverse();\n      return this.norm(_pose.data);\n    }\n    getTimeFeaturePose(vm) {\n      const fusion = this.localFusion;\n      if (!fusion)\n        return null;\n      let _pose = null;\n      if (this.poseFusions.length < 2 || !_PoseFusion.sim3DifferenceIsTooBig(this.lastFusion, fusion)) {\n        this.sFusion = fusion;\n      } else {\n        const lastLocTimestamp = this.poseFusions[this.poseFusions.length - 1].timestamp;\n        const _time = Date.now() / 1e3 - lastLocTimestamp;\n        const ratio = Math.min(1, _time);\n        this.sFusion = _PoseFusion.averageResult(this.lastFusion, fusion, ratio);\n      }\n      _pose = new Mat4().mul2(vm.clone(), this.sFusion.clone()).getInverse();\n      return this.norm(_pose.data);\n    }\n    norm(poseData) {\n      const _norm = Math.sqrt(\n        poseData[0] * poseData[0] + poseData[4] * poseData[4] + poseData[8] * poseData[8]\n      );\n      const norm_data = poseData.map((num, index) => {\n        if (index < 12 && index % 4 < 3) {\n          return num / _norm;\n        } else {\n          return num;\n        }\n      });\n      norm_data[15] = 1;\n      return norm_data;\n    }\n    clearFusion() {\n      this.poseFusions = [];\n      this.poseFusionResult = null;\n    }\n    static sim3DifferenceIsTooBig(lastResult, currentResult) {\n      const lastTran = lastResult.decompose();\n      const currentTran = currentResult.decompose();\n      const _data = lastTran.rotation.getInverse().mul(currentTran.rotation).data;\n      let deltaRadian = (_data[0] + _data[5] + _data[10] + _data[15] - 1.000001) / 2;\n      if (deltaRadian >= 1)\n        deltaRadian = 1;\n      if (deltaRadian <= -1)\n        deltaRadian = -1;\n      const deltaOmiga = Math.acos(deltaRadian) * 180 / Math.PI;\n      const deltaT_pos = {\n        x: lastTran.position.x - currentTran.position.x,\n        y: lastTran.position.y - currentTran.position.y,\n        z: lastTran.position.z - currentTran.position.z\n      };\n      const deltaT = Math.sqrt(\n        deltaT_pos.x * deltaT_pos.x + deltaT_pos.y * deltaT_pos.y + deltaT_pos.z * deltaT_pos.z\n      );\n      if (deltaT > 5 || deltaOmiga > 90) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    static averageResult(lastResult, currentResult, ratio) {\n      const _lastTans = lastResult.decompose();\n      const _currentTrans = currentResult.decompose();\n      const _lastQuat = new Quat().setFromMat4(lastResult);\n      const _currentQuat = new Quat().setFromMat4(currentResult);\n      const tempPos = {\n        x: _lastTans.position.x * (1 - ratio) + _currentTrans.position.x * ratio,\n        y: _lastTans.position.y * (1 - ratio) + _currentTrans.position.y * ratio,\n        z: _lastTans.position.z * (1 - ratio) + _currentTrans.position.z * ratio\n      };\n      const tempScale = {\n        x: _lastTans.scale.x * (1 - ratio) + _currentTrans.scale.x * ratio,\n        y: _lastTans.scale.y * (1 - ratio) + _currentTrans.scale.y * ratio,\n        z: _lastTans.scale.z * (1 - ratio) + _currentTrans.scale.z * ratio\n      };\n      const tempQuat = new Quat().slerp(_lastQuat, _currentQuat, ratio);\n      tempQuat.w = -tempQuat.w;\n      return new Mat4().setTRS(tempPos, tempQuat, tempScale);\n    }\n  };\n  let PoseFusion = _PoseFusion;\n  __publicField(PoseFusion, \"_instance\", null);\n  class CLSClient {\n    constructor(config$1) {\n      __publicField(this, \"config\");\n      __publicField(this, \"token\");\n      __publicField(this, \"clsdata\", {});\n      var _a;\n      assert(config$1.apiKey, \"apiKey \\u4E0D\\u4E3A\\u7A7A\");\n      assert(config$1.apiSecret, \"apiSecret \\u4E0D\\u4E3A\\u7A7A\");\n      assert(config$1.clsAppId, \"clsAppId \\u4E0D\\u4E3A\\u7A7A\");\n      if (!config$1.arannotationId && config$1.debug)\n        console.log(`!arannotationId,\\u5C06\\u83B7\\u53D6\\u6240\\u6709\\u6807\\u6CE8\\u6570\\u636E`);\n      this.config = config$1;\n      if (this.config.useCache === void 0)\n        this.config.useCache = true;\n      if (config$1.serverConfig) {\n        Object.assign(config, config$1.serverConfig);\n      }\n      this.config.autoFilterEma = (_a = config$1.autoFilterEma) != null ? _a : true;\n      this.config.debug && console.log(`autoFilterEma=true,\\u5C06\\u5F00\\u542F\\u8FC7\\u6EE4\\u6807\\u6CE8\\u6570\\u636E\\u6A21\\u5F0F`);\n    }\n    setConfig(config$1, reset) {\n      var _a;\n      reset != null ? reset : reset = true;\n      assert(config$1.apiKey, \"apiKey \\u4E0D\\u4E3A\\u7A7A\");\n      assert(config$1.apiSecret, \"apiSecret \\u4E0D\\u4E3A\\u7A7A\");\n      assert(config$1.clsAppId, \"clsAppId \\u4E0D\\u4E3A\\u7A7A\");\n      if (!config$1.arannotationId && config$1.debug)\n        console.log(`!arannotationId,\\u5C06\\u83B7\\u53D6\\u6240\\u6709\\u6807\\u6CE8\\u6570\\u636E`);\n      Object.assign(this.config, config$1);\n      if (config$1.serverConfig) {\n        Object.assign(config, config$1.serverConfig);\n      }\n      this.config.autoFilterEma = (_a = config$1.autoFilterEma) != null ? _a : true;\n      this.config.debug && console.log(`autoFilterEma=true,\\u5C06\\u5F00\\u542F\\u8FC7\\u6EE4\\u6807\\u6CE8\\u6570\\u636E\\u6A21\\u5F0F`);\n      if (reset)\n        this.clsdata = {};\n    }\n    getConfig() {\n      return this.config;\n    }\n    async getToken() {\n      this.token = await getToken(this.config.apiKey, this.config.apiSecret);\n      return this.token;\n    }\n    async getVersion() {\n      if (this.config.useCache && this.clsdata.clsVersion)\n        return this.clsdata.clsVersion;\n      const clsVersionRes = await getClsInfoAnonymous(this.config.clsAppId);\n      this.clsdata.clsVersion = clsVersionRes.version;\n      return this.clsdata.clsVersion;\n    }\n    async getClsHost() {\n      if (this.config.useCache && this.clsdata.clsHost)\n        return this.clsdata.clsHost;\n      await this.getVersion();\n      this.clsdata.clsHost = getClsHost(this.clsdata.clsVersion);\n      return this.clsdata.clsHost;\n    }\n    async getArannotations() {\n      if (this.config.useCache && this.clsdata.arannotations)\n        return this.clsdata.arannotations;\n      await this.getToken();\n      await this.getClsHost();\n      let araRes = await getArannotations(this.clsdata.clsHost, this.config.clsAppId, this.token);\n      let { arannotations } = araRes.result;\n      this.clsdata.arannotations = arannotations;\n      return this.clsdata.arannotations;\n    }\n    async getArannotationsDetail() {\n      if (this.config.useCache && this.clsdata.arannotationsDetail)\n        return this.clsdata.arannotationsDetail;\n      const arannotations = await this.getArannotations();\n      const arannotationsDetail = await Promise.all(arannotations.map((ara) => this._getEmaByArannotaionId(ara.arannotationId)));\n      Object.assign(this.clsdata, { arannotationsDetail });\n      return this.clsdata;\n    }\n    async getBlocksOnly() {\n      var _a, _b, _c, _d;\n      if (!((_b = (_a = this.clsdata) == null ? void 0 : _a.ema) == null ? void 0 : _b.blocks))\n        await this.getArannotationDetail(void 0, { ema: true, meta: false, autoFilterEma: false });\n      return ((_d = (_c = this.clsdata) == null ? void 0 : _c.ema) == null ? void 0 : _d.blocks) || [];\n    }\n    async getArannotationDetail(arannotationId, config2) {\n      if (!config2)\n        config2 = { ema: true, meta: true, autoFilterEma: true };\n      const arannotations = await this.getArannotations();\n      arannotationId = arannotationId != null ? arannotationId : this.config.arannotationId;\n      assert(arannotationId, \"arannotationId\\u4E0D\\u80FD\\u4E3A\\u7A7A\");\n      let ara = arannotations.find((aras) => aras.arannotationId == arannotationId);\n      if (!ara)\n        return Promise.reject(\"arannotationId\\u4E0D\\u5B58\\u5728\");\n      let clsdata = await this._getEmaByArannotaionId(ara.arannotationId, config2);\n      Object.assign(this.clsdata, clsdata);\n      return this.clsdata;\n    }\n    async _getEmaByArannotaionId(arannotationId, config$1) {\n      var _a;\n      if (!config$1)\n        config$1 = { ema: true, meta: true, autoFilterEma: true };\n      let res = await getArannotation(this.clsdata.clsHost, arannotationId, this.config.clsAppId, this.token);\n      let clsdata = { ema: null, meta: null, emaClusters: null, emaBlocks: null, emaMaps: null, emaRelationships: null };\n      const emaPromise = !(config$1.ema && res.result.emaUrl) ? Promise.resolve() : request(res.result.emaUrl.replace(\"https://large-spatialmaps.easyar.com\", config.emaUrl || \"/api/large-spatialmaps\"), \"GET\", null, { \"content-type\": \" \" }, null).then((res2) => {\n        var _a2, _b;\n        clsdata.ema = res2;\n        (_b = (_a2 = clsdata.ema) == null ? void 0 : _a2.blocks) == null ? void 0 : _b.map((block) => {\n          if (block.transform) {\n            if (block.transform instanceof Array) {\n              let mat4 = new Mat4();\n              mat4.set(block.transform);\n              block.mat4 = mat4;\n            } else if (block.transform.position && block.transform.rotation && block.transform.scale) {\n              let mat4 = new Mat4().compose(block.transform.position, block.transform.rotation, block.transform.scale);\n              block.mat4 = mat4;\n            } else {\n              throw new Error(\"config.transform \\u65E2\\u975E prs \\u53C8\\u975E number[]\");\n            }\n          }\n        });\n        return res2;\n      });\n      const metaPromise = !(config$1.meta && res.result.metaUrl) ? Promise.resolve() : request(res.result.metaUrl, \"GET\", null, { \"content-type\": \" \" }, null).then((res2) => {\n        clsdata.meta = res2;\n        return res2;\n      });\n      const [ema, meta] = await Promise.all([emaPromise, metaPromise]);\n      if (!((_a = config$1.autoFilterEma) != null ? _a : this.config.autoFilterEma))\n        return clsdata;\n      let { clusters, blocks, maps, relationships } = cubeListsFromEma(ema);\n      clsdata.emaClusters = clusters;\n      clsdata.emaBlocks = blocks;\n      clsdata.emaMaps = maps;\n      clsdata.emaRelationships = relationships;\n      return clsdata;\n    }\n  }\n  class Recognizer extends CLSClient {\n    constructor(config2, getCameraWithParam, slam = false) {\n      super(config2);\n      __publicField(this, \"inLoop\", false);\n      __publicField(this, \"busy\", false);\n      __publicField(this, \"request\");\n      __publicField(this, \"fireOnce\");\n      __publicField(this, \"data\", {\n        debug: 3,\n        includePerf: false\n      });\n      __publicField(this, \"canvas\");\n      __publicField(this, \"context\");\n      __publicField(this, \"cameraParam\");\n      __publicField(this, \"location\");\n      __publicField(this, \"multiMapHelper\");\n      __publicField(this, \"frameInterval\");\n      __publicField(this, \"frame\");\n      __publicField(this, \"minInterval\");\n      __publicField(this, \"onFound\");\n      __publicField(this, \"onLost\");\n      __publicField(this, \"onError\");\n      __publicField(this, \"poseFusion\");\n      __publicField(this, \"getCameraWithParam\");\n      if (getCameraWithParam) {\n        this.getCameraWithParam = getCameraWithParam;\n      }\n      if (slam) {\n        this.poseFusion = PoseFusion.getInstance();\n      }\n    }\n    _beginLoop() {\n      this.inLoop = true;\n      this.busy = false;\n    }\n    _stopLoop() {\n      if (this.request) {\n        this.request.abort();\n      }\n      this.inLoop = false;\n      this.busy = false;\n    }\n    start({ minInterval, onFound, onLost, onError }) {\n      this.minInterval = minInterval || this.minInterval;\n      this.onFound = onFound || this.onFound;\n      this.onLost = onLost || this.onLost;\n      this.onError = onError || this.onError;\n      this._resetCameraParam();\n      this._startFrameInterval();\n      this._beginLoop();\n    }\n    stop() {\n      this._stopLoop();\n      clearInterval(this.frameInterval);\n    }\n    _startFrameInterval() {\n      if (this.frameInterval)\n        clearInterval(this.frameInterval);\n      this.frameInterval = setInterval(() => {\n        this._triggerFrame();\n      }, this.minInterval, this);\n    }\n    async updateFrame() {\n      if (!this.getCameraWithParam) {\n        throw new Error(\"\\u8BF7\\u4F20\\u5165 getCameraWithParam \\u65B9\\u6CD5\");\n      }\n      let cameraImageWithPose = await this.getCameraWithParam();\n      return cameraImageWithPose;\n    }\n    _triggerFrame() {\n      if (this.busy)\n        return;\n      this.__trigger();\n    }\n    __trigger() {\n      if (this.inLoop) {\n        this.__fire();\n      } else if (this.fireOnce) {\n        this.fireOnce = false;\n        this.__fire();\n      }\n    }\n    run(frame) {\n      this.fireOnce = true;\n      if (frame)\n        this.updateFrame();\n      return this.__fire();\n    }\n    async __fire() {\n      if (this.busy)\n        return false;\n      this.busy = true;\n      let profile = {};\n      let token = void 0;\n      let res = null;\n      await this.getToken().then((t) => token = t).then((_) => this.updateFrame()).then((cameraImageWithPose) => {\n        profile.requestTime = cameraImageWithPose.timestamp;\n        profile.requestCameraPos = cameraImageWithPose.cameraPos;\n        profile.base64Time = new Date().getTime();\n        if (cameraImageWithPose.intrinsics) {\n          this.cameraParam = JSON.stringify(cameraImageWithPose.intrinsics);\n        }\n        console.log(\"\\u8F6C\\u6362\\u4E3Apost\\u8BF7\\u6C42\\u4E2D\\u7684\\u6587\\u4EF6\");\n        let data = this.__composeRequestFile(cameraImageWithPose.base64Img, token);\n        console.log(\"\\u53D1\\u9001\\u8BF7\\u6C42\");\n        return this.__sendClsRequest(data);\n      }).then((r) => {\n        console.log(\"cls\\u8BF7\\u6C42\\u7ED3\\u679C\", r);\n        res = this.__clsResult(r, profile);\n      }).catch((e) => {\n        console.log(\"cls\\u8BF7\\u6C42\\u5931\\u8D25\", e);\n        if (!(e && e.errMsg === \"request:fail abort\")) {\n          res = this.__clsError(e, profile);\n        }\n      }).then(() => {\n        this.busy = false;\n      });\n      return res;\n    }\n    __composeRequestFile(image, token) {\n      let params = {\n        appId: this.clsdata.clsAppId,\n        cameraParam: this.cameraParam\n      };\n      if (this.data.debug < 3)\n        console.log(\"params\", params);\n      if (this.data.debug < 2)\n        console.log(\"image\", image);\n      if (this.data.includePerf)\n        params.tprofile = 1;\n      let imageBuffer = base64ToArrayBuffer(image);\n      let banr1 = Object.keys(params).map((key) => {\n        return `\\r\n--XXX\\r\nContent-Disposition: form-data;name=\"${key}\"\\r\n\\r\n` + params[key];\n      }).join(\"\") + '\\r\\n--XXX\\r\\nContent-Disposition: form-data;name=\"image\"; filename=\"image.jpg\"\\r\\nContent-Type: application/octet-stream\\r\\nContent-Transfer-Encoding: binary\\r\\n\\r\\n';\n      let banr2 = \"\\r\\n--XXX--\";\n      let textEncoder = new text.TextEncoder();\n      let buffer1 = textEncoder.encode(banr1);\n      let buffer2 = new Uint8Array(imageBuffer);\n      let buffer3 = textEncoder.encode(banr2);\n      let all = new Uint8Array(buffer1.length + buffer2.length + buffer3.length);\n      all.set(buffer1, 0);\n      all.set(buffer2, buffer1.length);\n      all.set(buffer3, buffer1.length + buffer2.length);\n      let arraybuffer = all.buffer;\n      let version = this.clsdata.clsVersion;\n      return {\n        url: getClsUrl(version),\n        data: arraybuffer,\n        header: { \"content-type\": \"multipart/form-data; boundary=XXX\", Authorization: token }\n      };\n    }\n    __sendClsRequest(requestOptions) {\n      return new Promise((resolve, reject) => {\n        return new Promise((resolve2, reject2) => {\n          let options = Object.assign({\n            method: \"POST\",\n            success: (res) => {\n              resolve2(res.data);\n            },\n            fail: (err) => {\n              reject2(err);\n            },\n            complete: () => {\n              this.request = void 0;\n            }\n          }, requestOptions);\n          this.request = wx.request(options);\n        });\n      });\n    }\n    __clsResult(res, profile) {\n      var _a, _b;\n      let params = {};\n      params.statusCode = res.statusCode;\n      params.msg = res.msg;\n      if (this.data.includePerf) {\n        params.clientPerf = profile;\n        if (res.perf) {\n          params.serverPerf = res.perf;\n        }\n      }\n      if (res.timestamp)\n        params.timestamp = res.timestamp;\n      if (res.statusCode === 0) {\n        let result = res.result[0];\n        params.result = result;\n        let worlds = [];\n        if (result.mapId && (this.clsdata.emaMaps || this.clsdata.emaBlocks)) {\n          let mapCubeList = this.clsdata.emaMaps[result.mapId] || this.clsdata.emaBlocks[result.mapId];\n          if (mapCubeList && mapCubeList.length) {\n            let type = this.clsdata.emaMaps[result.mapId] ? \"map\" : \"block\";\n            let worldTransform = processPoseSchema(result.pose);\n            let cameraTransform = processPoseCamera(result.pose);\n            worlds.push({ type, contents: mapCubeList, pose: result.pose, worldTransform, cameraTransform });\n          }\n        }\n        params.worlds = worlds;\n        if (this.poseFusion) {\n          const arKitPos = Array.from(new Mat4().set(profile.requestCameraPos).clone().transpose().getInverse().data);\n          console.log(\"\\u8BF7\\u6C42\\u878D\\u5408\");\n          this.poseFusion.insertData(arKitPos, result.pose, profile.requestTime).then((res2) => {\n            var _a2;\n            console.log(\"\\u878D\\u5408\\u7ED3\\u679C\", res2);\n            params.fusionsStatus = res2 == null ? void 0 : res2.status;\n            params.fusionPose = res2 == null ? void 0 : res2.fusionPose;\n            (_a2 = this.onFound) == null ? void 0 : _a2.call(this, params);\n          });\n        } else {\n          (_a = this.onFound) == null ? void 0 : _a.call(this, params);\n        }\n      } else {\n        console.log(\"\\u8BC6\\u522B\\u5931\\u8D25\", res);\n        (_b = this.onLost) == null ? void 0 : _b.call(this, params);\n      }\n      return params;\n    }\n    getPoseInMap(vm) {\n      if (this.poseFusion) {\n        return this.poseFusion.getPoseInMap(vm);\n      } else {\n        console.error(\"getPoseInMap--> poseFusion is not exist\");\n        return Array.from(new Mat4().data);\n      }\n    }\n    __clsError(err, profile) {\n      var _a;\n      let params = {};\n      params.error = err;\n      params.msg = err.errMsg;\n      if (this.data.includePerf)\n        params.clientPerf = profile;\n      (_a = this.onError) == null ? void 0 : _a.call(this, params);\n      return params;\n    }\n    _resetCameraParam() {\n      let size = [480, 640];\n      let focal = [544, 544];\n      let canvas = this.canvas && this.canvas.width && { width: this.canvas.width, height: this.canvas.width * 4 / 3 } || { width: 480, height: 640 };\n      let ratio = canvas.height / size[1];\n      let focalLength = [focal[0] * ratio, focal[1] * ratio];\n      let principalPoint = [canvas.width / 2, canvas.height / 2];\n      this.cameraParam = \"[\" + focalLength[0] + \",\" + focalLength[1] + \",\" + principalPoint[0] + \",\" + principalPoint[1] + \"]\";\n    }\n  }\n  exports2.CLSClient = CLSClient;\n  exports2.Recognizer = Recognizer;\n  Object.defineProperties(exports2, { __esModule: { value: true }, [Symbol.toStringTag]: { value: \"Module\" } });\n});\n"]}